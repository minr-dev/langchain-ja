# Redis | Redis

> [Redis（Remote Dictionary Server）](https://en.wikipedia.org/wiki/Redis)は、オープンソースのインメモリストレージであり、分散型のインメモリキー・バリューデータベース、キャッシュ、メッセージブローカーとして使用され、オプションで耐久性を提供することも可能です。全てのデータをメモリ内に保持することと、その設計により、`Redis`は低レイテンシの読み書きを実現し、キャッシュが必要とされるユースケースに特に適しています。Redisは最も人気のあるNoSQLデータベースであり、全体的に見ても最も人気のあるデータベースの一つです。
>
> > [Redis (Remote Dictionary Server)](https://en.wikipedia.org/wiki/Redis) is an open-source in-memory storage,
> > used as a distributed, in-memory key–value database, cache and message broker, with optional durability.
> > Because it holds all data in memory and because of its design, `Redis` offers low-latency reads and writes,
> > making it particularly suitable for use cases that require a cache. Redis is the most popular NoSQL database,
> > and one of the most popular databases overall.

このページでは、LangChain内で[Redis](https://redis.com)エコシステムを使用する方法について説明しています。内容は、インストールとセットアップに関する部分と、特定のRedisラッパーに関する参照部分の2つに分けられています。

> This page covers how to use the [Redis](https://redis.com) ecosystem within LangChain.
> It is broken into two parts: installation and setup, and then references to specific Redis wrappers.

## Installation and Setup | インストールとセットアップ

Python SDKをインストールする：

> Install the Python SDK:

```bash
pip install redis
```

Redisをローカルで実行するには、Dockerを使用できます。

> To run Redis locally, you can use Docker:

```bash
docker run --name langchain-redis -d -p 6379:6379 redis redis-server --save 60 1 --loglevel warning
```

コンテナを停止するには：

> To stop the container:

```bash
docker stop langchain-redis
```

そして、それを再開するには：

> And to start it again:

```bash
docker start langchain-redis
```

## Wrappers | ラッパー

すべてのラッパーは、データベースサポートに接続するために、単独のRedisサーバーまたはレプリケーションとRedisセンチネルを備えた高可用性セットアップに対応するRedis URL接続文字列を必要とします。

> All wrappers need a redis url connection string to connect to the database support either a stand alone Redis server
> or a High-Availability setup with Replication and Redis Sentinels.

### Redis Standalone connection url | Redis スタンドアロン接続 URL

スタンドアロンの`Redis`サーバーについては、公式のRedis接続URLフォーマットを使用できます。これはPythonのredisモジュールの`from_url()`メソッドで説明されています。詳細は[Redis.from\_url](https://redis-py.readthedocs.io/en/stable/connections.html#redis.Redis.from_url)を参照してください。

> For standalone `Redis` server, the official redis connection url formats can be used as describe in the python redis modules
> "from\_url()" method [Redis.from\_url](https://redis-py.readthedocs.io/en/stable/connections.html#redis.Redis.from_url)

例：`redis_url = "redis://:secret-pass@localhost:6379/0"`

> Example: `redis_url = "redis://:secret-pass@localhost:6379/0"`

### Redis Sentinel connection url | Redis Sentinel 接続 URL

[Redisセンチネル設定](https://redis.io/docs/management/sentinel/)において、接続スキームは「redis+sentinel」です。センチネル用の接続URLが利用できない限り、これは公式のIANA登録プロトコルスキームに対する非公式の拡張です。

> For [Redis sentinel setups](https://redis.io/docs/management/sentinel/) the connection scheme is "redis+sentinel".
> This is an unofficial extensions to the official IANA registered protocol schemes as long as there is no connection url
> for Sentinels available.

例：`redis_url = "redis+sentinel://:secret-pass@sentinel-host:26379/mymaster/0"`

> Example: `redis_url = "redis+sentinel://:secret-pass@sentinel-host:26379/mymaster/0"`

`redis+sentinel://[[username]:[password]]@[host-or-ip]:[port]/[service-name]/[db-number]`の形式で、特に指定がない場合のデフォルト値は、「service-name = mymaster」と「db-number = 0」です。service-nameはSentinel内で設定されるRedisサーバーの監視グループ名です。

> The format is  `redis+sentinel://[[username]:[password]]@[host-or-ip]:[port]/[service-name]/[db-number]`
> with the default values of "service-name = mymaster" and "db-number = 0" if not set explicit.
> The service-name is the redis server monitoring group name as configured within the Sentinel.

現在のURL形式では、接続文字列にセンチネルホストを一つだけ指定できます（リストは指定できません）。また、Redisサーバーとセンチネルは、使用される場合は同じパスワードを設定しなければなりません。

> The current url format limits the connection string to one sentinel host only (no list can be given) and
> booth Redis server and sentinel must have the same password set (if used).

### Redis Cluster connection url | Redis Cluster 接続 URL

現在、'redis\_url' パラメータを必要とするすべてのメソッドでRedisクラスターはサポートされていません。Redisクラスターを使用する唯一の方法は、`RedisCache`のような事前に設定されたRedisクライアントを受け入れるLangChainクラスを使用することです（下記の例を参照）。

> Redis cluster is not supported right now for all methods requiring a "redis\_url" parameter.
> The only way to use a Redis Cluster is with LangChain classes accepting a preconfigured Redis client like `RedisCache`
> (example below).

### Cache | キャッシュ

Cacheラッパーを使用すると、[Redis](https://redis.io)をリモートで低遅延のインメモリキャッシュとして、LLMのプロンプトとレスポンスに利用できます。

> The Cache wrapper allows for [Redis](https://redis.io) to be used as a remote, low-latency, in-memory cache for LLM prompts and responses.

#### Standard Cache | 標準キャッシュ

標準のキャッシュは、世界中の[オープンソース](https://redis.io)ユーザーと[エンタープライズ](https://redis.com)ユーザーの両方にとって、本番環境での使用例におけるRedisの主食です。

> The standard cache is the Redis bread & butter of use case in production for both [open-source](https://redis.io) and [enterprise](https://redis.com) users globally.

このキャッシュをインポートするには：

> To import this cache:

```python
from langchain.cache import RedisCache
```

このキャッシュをあなたのLLMと一緒に使用するには：

> To use this cache with your LLMs:

```python
from langchain.globals import set_llm_cache
import redis

redis_client = redis.Redis.from_url(...)
set_llm_cache(RedisCache(redis_client))
```

#### Semantic Cache | セマンティックキャッシュ

セマンティックキャッシングは、ユーザー入力と以前にキャッシュされた結果とのセマンティックな類似性に基づいて、キャッシュされたプロンプトを取得することを可能にします。内部では、キャッシュとベクターストアの両方としてRedisを活用しています。

> Semantic caching allows users to retrieve cached prompts based on semantic similarity between the user input and previously cached results. Under the hood it blends Redis as both a cache and a vectorstore.

このキャッシュをインポートするには：

> To import this cache:

```python
from langchain.cache import RedisSemanticCache
```

このキャッシュをあなたのLLMと一緒に使用するには：

> To use this cache with your LLMs:

```python
from langchain.globals import set_llm_cache
import redis

# use any embedding provider...
from tests.integration_tests.vectorstores.fake_embeddings import FakeEmbeddings

redis_url = "redis://localhost:6379"

set_llm_cache(RedisSemanticCache(
    embedding=FakeEmbeddings(),
    redis_url=redis_url
))
```

### VectorStore | VectorStore

vectorstoreラッパーは、Redisを低遅延の[ベクターデータベース](https://redis.com/solutions/use-cases/vector-database/)に変換し、セマンティック検索やLLMコンテンツの取得に利用できます。

> The vectorstore wrapper turns Redis into a low-latency [vector database](https://redis.com/solutions/use-cases/vector-database/) for semantic search or LLM content retrieval.

このベクトルストアをインポートするには：

> To import this vectorstore:

```python
from langchain.vectorstores import Redis
```

Redis vectorstoreラッパーのより詳細なウォークスルーについては、[このノートブック](/docs/integrations/vectorstores/redis)をご覧ください。

> For a more detailed walkthrough of the Redis vectorstore wrapper, see [this notebook](/docs/integrations/vectorstores/redis).

### Retriever | リトリーバー

Redisベクターストアリトリーバラッパーは、低遅延でドキュメントを取得するためにvectorstoreクラスを一般化します。リトリーバを作成するには、基本となるvectorstoreクラスに`.as_retriever()`を呼び出すだけです。

> The Redis vector store retriever wrapper generalizes the vectorstore class to perform low-latency document retrieval. To create the retriever, simply call `.as_retriever()` on the base vectorstore class.

### Memory | メモリ

Redisは、LLMの会話を永続化するために使用することができます。

> Redis can be used to persist LLM conversations.

#### Vector Store Retriever Memory | ベクトルストアリトリーバメモリ

`VectorStoreRetrieverMemory`ラッパーのより詳細なウォークスルーについては、[このノートブック](/docs/modules/memory/types/vectorstore_retriever_memory)をご覧ください。

> For a more detailed walkthrough of the `VectorStoreRetrieverMemory` wrapper, see [this notebook](/docs/modules/memory/types/vectorstore_retriever_memory).

#### Chat Message History Memory | チャットメッセージ履歴メモリ

Redisを使用して会話メッセージの履歴をキャッシュする詳細な例については、[このノートブック](/docs/integrations/memory/redis_chat_message_history)をご覧ください。

> For a detailed example of Redis to cache conversation message history, see [this notebook](/docs/integrations/memory/redis_chat_message_history).
